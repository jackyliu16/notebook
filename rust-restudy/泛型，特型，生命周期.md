## 泛型
```ad-note

满足一般化函数类型的需求，避免编写重复的代码
```
 
```rust
impl<T, E> Result<T, E> {
	fn is_ok(&self) -> bool {
		match *self {
			Ok(_) => true,
			Err(_) => false,
		}
	}
}
```

## 特型（trait）

```ad-note
一些类型具有共性
针对于每一种对应的类型进行实现是可行的，但是缺乏一种结构性

使用`trait`代码段来定义trait，同时列出对应trait所需要的方法的签名，但是不包括定义【不一定大大多数】（不同于impl）
```

```
```rust
struct Point {
	x: i32,
	y: i32,
}
impl Point {
	fn format(&self) -> String { ... }
	fn equals(&self, other: Point) -> bool { ... }
}
// 使用trait
trait PrettyPrint {
	fn format(&self) -> String;
}
impl PrettyPrint for Point {
	fn format(&self) -> String {
		format!("...")
	}
}
```

rust 想对于类型参数进行约束的方法：特型，特性约束可以直接在类型参数的地方使用`T: SomeTrait` 或者在后面跟上`where T:SomeTrait` 来对其进行指定\[目前不支持反向约束\]

```rust
// 约束其能满足特型要求
fn cloning_machine<T: Clone + Ord>(t: T) -> (T, T) {
	(t.clone(), t.clone())
}
fn cloning_machine<T>(t: T) -> (T, T) 
	where T: Clone + Ord {
	(t.clone(), t.clone())
}
```

同样也可以定义具有特型约束的泛型结构体和枚举类型，需要在其代码头部声明对应的泛型参数，只有 impl 代码段的特型约束是必须要制定的，可以在同一个 struct or enum 处实现不同的泛型

```rust
enum Result<T, E> {
	Ok(T),
	Err(E),
}
trait PrettyPrint{
	fn format(&self) -> String;
}
impl<T, E> PrettyPrint for Result<T, E>
where 
	T: PrettyPrint
	E: PrettyPrint	
{
	fn format(&self) -> String {
		match *self {
			Ok(t) => ...,
			Err(e) => ...,
		}
	}
}
trait Equals{
	fn equals(&self, other：&Self) -> bool;
}
impl<T, E> Equals for Result<T, E> 
where 
	T: Equals,
	E: Equals 
{
	fn equals(&self, other:&Self) -> bool {
		match (*self, *other) {
			... 
		}
	}
}
```

self 方法以及其作用的对象本身
Self 对象的类型

#### 面向对象设计的三大思想
> 封装，继承，多态
> 封装：将一系列东西封装在一个 struct or enum 中
> 多态：可以通过传入不同的类型，引导向不同的方法来实现多态？
> 继承：特性之间存在逻辑上的先后关系
> 	Eq 需要先实现 PartialEq
> 	Copy 需要先实现 Clone
```rust
trait Parent {
	fn foo(&self) { ... }
}
trait Child: Parent {
	fn bar(&self) {
		self.foo();
	}
}
```

#### 默认方法

> trait 可以制定默认的方法实现以避免重复实现哪些具有一般意义上常见实现的方法
> 当某个方法在 trait 中定义默认实现时，特型的实现中就不用再定义这个方法
> 默认实现的方式是在 trait 代码段写出方法的实现

```rust
trait PartialEq<Rhs: ?Sized = Self> {
	fn eq(&self, other: &Rhs) -> bool;
	fn ne(&self, other: &Rhs) -> bool { !self.eq(other) } // 默认实现
}
```

在实现特型的时候可以改动默认方法的实现，但是一定要具有充分的理由
可以通过 \[drive(Debug, PartialEq)\] 等来自动实现 trait，但是这种实现方式存在一定限制，比如说要求其中的元素必须要满足先前 trait 的要求(如f32不能实现Eq, 因为其没有实现 Eq 的前置 PartialEq)，这样做可以避免重复手动实现诸如 Clone 这样的 trait，但是能直接使用的 trait 相对比较少
> Clone, Copy, Debug, Default, Eq
> Hash, Ord, PartialEq, PartialOrd

*对于当前不支持的 trait 可以使用宏来完成特型的自动获得*

- Clone
	- 定义如何复制 T 的一个值
	- method
		- clone(&self) -> Self;
		- clone_from(&mut self, source: &Self) {...}
- Copy
	- 表现一种类型是**拷贝语义**, 而并非默认的**移动语义**
	- 类型必须**可以通过位拷贝来进行拷贝（memcopy）**\[引用的就不行了\]
	- **标记 trait**：并没有实现方法，只是对于行为进行了标记
	- 一般来说只要类型可以进行拷贝，就应该实现这个特型
- Debug
	- 定义能够使用 {:?} 格式选项进行输出
	- 产生的是用于调试的信息，有点类似python的repr？
	- method: fmt(&self, &mut Formatter) -> Result;
- Default
	- 定义默认值
	- method: default() -> Self;
- PartialEq and Eq
	- PartialEq 表示部分等价关系
		- 对称性以及传递性
		- method
			- eq(&self, other: &Rhs) -> bool;
			- ne(&self, other: &Rhs) -> bool;
	- Eq 表示等价关系
		- 在对称性和传递性之外还需要满足自反性
		- **标记 trait**：并没有实现方法，只是对于行为进行了标记
- Hash 
	- 表示可以进行 hash 运算的类型
	- method
		- H: 抽象的Hash状态，用于计算hash
		- hash<H: Hasher>(&self, state: &mut H);
		- hash_slice<H: Hasher>(data: &[self], state: &mut H) 
		  where Self: Sized
- PartialOrd<Rhs: ?Sized = Self>: ParticalEq \<Rhs\> 
	- 表示可能用来相互进行顺序上的比较
	- 比较必须满足：反对称性，传递性	- 
	- method
		- lt(&self, other: &Rhs) -> bool；
		- le(&self, other: &Rhs) -> bool；
		- gt(&self, other: &Rhs) -> bool；
		- ge(&self, other: &Rhs) -> bool；
		- partial_cmp(&self, other: &Rhs) -> Option \<Ordering\>
		  enum Ordering: Less, Equal, Greater
- Ord: Eq + PartialOrd
	- 形成了全序关系，可以按照字典序进行排序
	- 在反对称性和传递性外还需要满足完全性
	- method： cmp(&self, other: &Self) -> Ordering;

**关联特性**
```rust
trait Graph<N, E> {
	fn edges(&Self, &N) -> Vec<E>;
}
fn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 {...}
```
虽然 N, E 都是泛型，但是关系不太明确，在实现过程中还需要同样实现对应的泛型
```rust
trait Graph {
	type N;
	type E;
	fn edges(&self, &Self::N) -> Vec<Self::E>;
}
impl Graph for MyGraph {
	type N = MyNode;
	type E = MyEdge;
	fn edges(&self, n: &MyNode) -> Vec<MyEdge>;
}
```

**trait 作用域**
实现特性的作用域规则：
- 需要 use 要用的特型来访问类型中的由这种 trait 定义的方法，即使已有对于类型的访问权限也是不够的
- 为了写一个 trait 的 impl 需要**至少拥有**（用自己的代码定义）特型或者拥有该类型

**常用特型**
- Display
	- 定义标准打印的输出行为，用于美观打印，不能自动获得，通过 write！宏完成具体实现
	- method fmt(&self, f: &mut Formatter) -> Result<(), Error> {...}
- Drop
	- 表示可以销毁的 trait (all) 提供函数将对象 Drop
	- 一般只在对象销毁的时候有特殊行为的时候才需要手动实现，比如说Rc\<T\>引用计数器
	- method: drop(&mut self);
- Sized and ?Sized
	- Sized  表示在编译的时候已知固定的大小
	- ?Sized 表示一种类型的大小可能是不固定的
	- 默认情况下所有类型都是Sized，只有制定?Sized 可以撤销这个规定
	- 一般而言，跟指针相关的泛型的类型参数中的 trait 约束会出现?Sized,比如Box\<T\> T: ?Sized

