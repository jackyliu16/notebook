[reference](https://github.com/YdrMaster/notebook/blob/main/topics/unikraft/20220926-unikernel.md)
>在软件工程中，反模式（anti-pattern）指的是一些重复出现的、乍一看是有益的，但最终得不偿失的模式。过去，这个词仅仅用于形容那些在 Java 这样的语言中滥用设计模式，导致无效代码膨胀的现象。但随着时间的流逝，很多原本我们认为是理所当然的事，正在成为阻碍我们前进的障碍。
>
>传统上，我们把操作系统定义为计算机软硬件之间的桥梁，负责操作和分配计算机硬件资源，并调度用户计算任务，为用户提供服务。从计算机这种机器诞生之初，在过去的五、六十年里，符合此种定义的操作系统不断进步，目前仍在几乎所有的计算机上运行。但最近的十年里，事情正在发生变化。云技术的进步使得许多个人用户分享同一台计算机的需求飞速发展。所有随之而来的隔离性、扩展性、移植性，以及快速启动和迁移，以及故障时快速恢复的需求，传统操作系统已无力承担，各种虚拟化软件随之而来。
>
>内核态与用户态的隔离保证了操作系统的稳定运行，但也使得用户态享受内核服务需要通过中断与系统调用，开销比调用相同功能的函数大很多。但在虚拟机中，虚拟机监视程序（Hypervisor）必然需要也已经提供了更强的的安全保护，操作系统与应用程序之间隔离的重要性就变低了，为了这次隔离而付出的性能代价也开始变得越来越不可接受。
>
>具体来说，隔离体现在特权级的**隔离和地址空间的隔离**。在应用程序的视角，系统调用（System Call）和函数调用（Function Call）并没有什么不同，甚至如今大部分高级语言中 POSIX 系统调用都是通过 libc 库提供的函数调用封装完成的。但系统调用的开销大得多，因为特权级的切换和地址空间的切换不止需要额外的操作，而且破坏了所有局部性，造成了各种缓存不命中损失。传统操作系统的核心技术，现在成为反模式了。
>
>于是我们发明了库操作系统（Libary OS），去除操作系统的隔离性，让操作系统退化成类似 libc 的库，通过函数调用给应用程序提供服务。现在，操作系统和应用程序运行在同一个特权级、同一个地址空间了，由于运行在同一个地址空间，操作系统现在只能服务一个传统的独占地址空间的应用程序进程。这样的操作系统内核，被称为 Unikernel。类比于宏内核（Monolithic kernel）、微内核（Microkernel），可称为幺内核。

#安全性疑惑 
在相当大的程度上，Libary OS的提出其实从很大程度上通过削减了因为内核地址空间以及特权级别的抽象为计算机系统带来的安全性保证，而因而需要更进一步的要求操作系统中的各个组件必须是安全的，否则在没有操作系统的限制下，其安全性也就更加没有办法得到保证 
*(在我当前浅薄的网络安全知识下，我对于这个地方的安全性有所质疑，但是不排除我所质疑点根本就不存在)*

